"use strict";

/**
 * @license
 * Part of dygraphs, see top-level LICENSE.txt file
 * MIT-licenced: https://opensource.org/licenses/MIT
 */

/* loader wrapper to allow browser use and ES6 imports */
(function _extras_smoothPlotter_closure() {
  'use strict';

  var Dygraph;
  if (window.Dygraph) {
    Dygraph = window.Dygraph;
  } else if (typeof module !== 'undefined') {
    Dygraph = require('../dygraph');
    if (typeof Dygraph.NAME === 'undefined' && typeof Dygraph["default"] !== 'undefined') Dygraph = Dygraph["default"];
  }
  /* end of loader wrapper header */

  /**
   * Given three sequential points, p0, p1 and p2, find the left and right
   * control points for p1.
   *
   * The three points are expected to have x and y properties.
   *
   * The alpha parameter controls the amount of smoothing.
   * If α=0, then both control points will be the same as p1 (i.e. no smoothing).
   *
   * Returns [l1x, l1y, r1x, r1y]
   *
   * It's guaranteed that the line from (l1x, l1y)-(r1x, r1y) passes through p1.
   * Unless allowFalseExtrema is set, then it's also guaranteed that:
   *   l1y ∈ [p0.y, p1.y]
   *   r1y ∈ [p1.y, p2.y]
   *
   * The basic algorithm is:
   * 1. Put the control points l1 and r1 α of the way down (p0, p1) and (p1, p2).
   * 2. Shift l1 and r2 so that the line l1–r1 passes through p1
   * 3. Adjust to prevent false extrema while keeping p1 on the l1–r1 line.
   *
   * This is loosely based on the HighCharts algorithm.
   */
  function getControlPoints(p0, p1, p2, opt_alpha, opt_allowFalseExtrema) {
    var alpha = opt_alpha !== undefined ? opt_alpha : 1 / 3; // 0=no smoothing, 1=crazy smoothing
    var allowFalseExtrema = opt_allowFalseExtrema || false;
    if (!p2) {
      return [p1.x, p1.y, null, null];
    }

    // Step 1: Position the control points along each line segment.
    var l1x = (1 - alpha) * p1.x + alpha * p0.x,
      l1y = (1 - alpha) * p1.y + alpha * p0.y,
      r1x = (1 - alpha) * p1.x + alpha * p2.x,
      r1y = (1 - alpha) * p1.y + alpha * p2.y;

    // Step 2: shift the points up so that p1 is on the l1–r1 line.
    if (l1x != r1x) {
      // This can be derived w/ some basic algebra.
      var deltaY = p1.y - r1y - (p1.x - r1x) * (l1y - r1y) / (l1x - r1x);
      l1y += deltaY;
      r1y += deltaY;
    }

    // Step 3: correct to avoid false extrema.
    if (!allowFalseExtrema) {
      if (l1y > p0.y && l1y > p1.y) {
        l1y = Math.max(p0.y, p1.y);
        r1y = 2 * p1.y - l1y;
      } else if (l1y < p0.y && l1y < p1.y) {
        l1y = Math.min(p0.y, p1.y);
        r1y = 2 * p1.y - l1y;
      }
      if (r1y > p1.y && r1y > p2.y) {
        r1y = Math.max(p1.y, p2.y);
        l1y = 2 * p1.y - r1y;
      } else if (r1y < p1.y && r1y < p2.y) {
        r1y = Math.min(p1.y, p2.y);
        l1y = 2 * p1.y - r1y;
      }
    }
    return [l1x, l1y, r1x, r1y];
  }

  // i.e. is none of (null, undefined, NaN)
  function isOK(x) {
    return !!x && !isNaN(x);
  }
  ;

  // A plotter which uses splines to create a smooth curve.
  // See tests/plotters.html for a demo.
  // Can be controlled via smoothPlotter.smoothing
  function smoothPlotter(e) {
    var ctx = e.drawingContext,
      points = e.points;
    ctx.beginPath();
    ctx.moveTo(points[0].canvasx, points[0].canvasy);

    // right control point for previous point
    var lastRightX = points[0].canvasx,
      lastRightY = points[0].canvasy;
    for (var i = 1; i < points.length; i++) {
      var p0 = points[i - 1],
        p1 = points[i],
        p2 = points[i + 1];
      p0 = p0 && isOK(p0.canvasy) ? p0 : null;
      p1 = p1 && isOK(p1.canvasy) ? p1 : null;
      p2 = p2 && isOK(p2.canvasy) ? p2 : null;
      if (p0 && p1) {
        var controls = getControlPoints({
          x: p0.canvasx,
          y: p0.canvasy
        }, {
          x: p1.canvasx,
          y: p1.canvasy
        }, p2 && {
          x: p2.canvasx,
          y: p2.canvasy
        }, smoothPlotter.smoothing);
        // Uncomment to show the control points:
        // ctx.lineTo(lastRightX, lastRightY);
        // ctx.lineTo(controls[0], controls[1]);
        // ctx.lineTo(p1.canvasx, p1.canvasy);
        lastRightX = lastRightX !== null ? lastRightX : p0.canvasx;
        lastRightY = lastRightY !== null ? lastRightY : p0.canvasy;
        ctx.bezierCurveTo(lastRightX, lastRightY, controls[0], controls[1], p1.canvasx, p1.canvasy);
        lastRightX = controls[2];
        lastRightY = controls[3];
      } else if (p1) {
        // We're starting again after a missing point.
        ctx.moveTo(p1.canvasx, p1.canvasy);
        lastRightX = p1.canvasx;
        lastRightY = p1.canvasy;
      } else {
        lastRightX = lastRightY = null;
      }
    }
    ctx.stroke();
  }
  smoothPlotter.smoothing = 1 / 3;
  smoothPlotter._getControlPoints = getControlPoints; // for testing

  // older versions exported a global.
  // This will be removed in the future.
  // The preferred way to access smoothPlotter is via Dygraph.smoothPlotter.
  window.smoothPlotter = smoothPlotter;
  Dygraph.smoothPlotter = smoothPlotter;

  /* closure and loader wrapper */
  Dygraph._required('dygraphs/src/extras/smooth-plotter.js', /* exports */{});
})();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfZXh0cmFzX3Ntb290aFBsb3R0ZXJfY2xvc3VyZSIsIkR5Z3JhcGgiLCJ3aW5kb3ciLCJtb2R1bGUiLCJyZXF1aXJlIiwiTkFNRSIsImdldENvbnRyb2xQb2ludHMiLCJwMCIsInAxIiwicDIiLCJvcHRfYWxwaGEiLCJvcHRfYWxsb3dGYWxzZUV4dHJlbWEiLCJhbHBoYSIsInVuZGVmaW5lZCIsImFsbG93RmFsc2VFeHRyZW1hIiwieCIsInkiLCJsMXgiLCJsMXkiLCJyMXgiLCJyMXkiLCJkZWx0YVkiLCJNYXRoIiwibWF4IiwibWluIiwiaXNPSyIsImlzTmFOIiwic21vb3RoUGxvdHRlciIsImUiLCJjdHgiLCJkcmF3aW5nQ29udGV4dCIsInBvaW50cyIsImJlZ2luUGF0aCIsIm1vdmVUbyIsImNhbnZhc3giLCJjYW52YXN5IiwibGFzdFJpZ2h0WCIsImxhc3RSaWdodFkiLCJpIiwibGVuZ3RoIiwiY29udHJvbHMiLCJzbW9vdGhpbmciLCJiZXppZXJDdXJ2ZVRvIiwic3Ryb2tlIiwiX2dldENvbnRyb2xQb2ludHMiLCJfcmVxdWlyZWQiXSwic291cmNlcyI6WyIuLi8uLi9zcmMvZXh0cmFzL3Ntb290aC1wbG90dGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIFBhcnQgb2YgZHlncmFwaHMsIHNlZSB0b3AtbGV2ZWwgTElDRU5TRS50eHQgZmlsZVxuICogTUlULWxpY2VuY2VkOiBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxuICovXG5cbi8qIGxvYWRlciB3cmFwcGVyIHRvIGFsbG93IGJyb3dzZXIgdXNlIGFuZCBFUzYgaW1wb3J0cyAqL1xuKGZ1bmN0aW9uIF9leHRyYXNfc21vb3RoUGxvdHRlcl9jbG9zdXJlKCkge1xuJ3VzZSBzdHJpY3QnO1xudmFyIER5Z3JhcGg7XG5pZiAod2luZG93LkR5Z3JhcGgpIHtcbiAgRHlncmFwaCA9IHdpbmRvdy5EeWdyYXBoO1xufSBlbHNlIGlmICh0eXBlb2YobW9kdWxlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgRHlncmFwaCA9IHJlcXVpcmUoJy4uL2R5Z3JhcGgnKTtcbiAgaWYgKHR5cGVvZihEeWdyYXBoLk5BTUUpID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YoRHlncmFwaC5kZWZhdWx0KSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgRHlncmFwaCA9IER5Z3JhcGguZGVmYXVsdDtcbn1cbi8qIGVuZCBvZiBsb2FkZXIgd3JhcHBlciBoZWFkZXIgKi9cblxuLyoqXG4gKiBHaXZlbiB0aHJlZSBzZXF1ZW50aWFsIHBvaW50cywgcDAsIHAxIGFuZCBwMiwgZmluZCB0aGUgbGVmdCBhbmQgcmlnaHRcbiAqIGNvbnRyb2wgcG9pbnRzIGZvciBwMS5cbiAqXG4gKiBUaGUgdGhyZWUgcG9pbnRzIGFyZSBleHBlY3RlZCB0byBoYXZlIHggYW5kIHkgcHJvcGVydGllcy5cbiAqXG4gKiBUaGUgYWxwaGEgcGFyYW1ldGVyIGNvbnRyb2xzIHRoZSBhbW91bnQgb2Ygc21vb3RoaW5nLlxuICogSWYgzrE9MCwgdGhlbiBib3RoIGNvbnRyb2wgcG9pbnRzIHdpbGwgYmUgdGhlIHNhbWUgYXMgcDEgKGkuZS4gbm8gc21vb3RoaW5nKS5cbiAqXG4gKiBSZXR1cm5zIFtsMXgsIGwxeSwgcjF4LCByMXldXG4gKlxuICogSXQncyBndWFyYW50ZWVkIHRoYXQgdGhlIGxpbmUgZnJvbSAobDF4LCBsMXkpLShyMXgsIHIxeSkgcGFzc2VzIHRocm91Z2ggcDEuXG4gKiBVbmxlc3MgYWxsb3dGYWxzZUV4dHJlbWEgaXMgc2V0LCB0aGVuIGl0J3MgYWxzbyBndWFyYW50ZWVkIHRoYXQ6XG4gKiAgIGwxeSDiiIggW3AwLnksIHAxLnldXG4gKiAgIHIxeSDiiIggW3AxLnksIHAyLnldXG4gKlxuICogVGhlIGJhc2ljIGFsZ29yaXRobSBpczpcbiAqIDEuIFB1dCB0aGUgY29udHJvbCBwb2ludHMgbDEgYW5kIHIxIM6xIG9mIHRoZSB3YXkgZG93biAocDAsIHAxKSBhbmQgKHAxLCBwMikuXG4gKiAyLiBTaGlmdCBsMSBhbmQgcjIgc28gdGhhdCB0aGUgbGluZSBsMeKAk3IxIHBhc3NlcyB0aHJvdWdoIHAxXG4gKiAzLiBBZGp1c3QgdG8gcHJldmVudCBmYWxzZSBleHRyZW1hIHdoaWxlIGtlZXBpbmcgcDEgb24gdGhlIGwx4oCTcjEgbGluZS5cbiAqXG4gKiBUaGlzIGlzIGxvb3NlbHkgYmFzZWQgb24gdGhlIEhpZ2hDaGFydHMgYWxnb3JpdGhtLlxuICovXG5mdW5jdGlvbiBnZXRDb250cm9sUG9pbnRzKHAwLCBwMSwgcDIsIG9wdF9hbHBoYSwgb3B0X2FsbG93RmFsc2VFeHRyZW1hKSB7XG4gIHZhciBhbHBoYSA9IChvcHRfYWxwaGEgIT09IHVuZGVmaW5lZCkgPyBvcHRfYWxwaGEgOiAxLzM7ICAvLyAwPW5vIHNtb290aGluZywgMT1jcmF6eSBzbW9vdGhpbmdcbiAgdmFyIGFsbG93RmFsc2VFeHRyZW1hID0gb3B0X2FsbG93RmFsc2VFeHRyZW1hIHx8IGZhbHNlO1xuXG4gIGlmICghcDIpIHtcbiAgICByZXR1cm4gW3AxLngsIHAxLnksIG51bGwsIG51bGxdO1xuICB9XG5cbiAgLy8gU3RlcCAxOiBQb3NpdGlvbiB0aGUgY29udHJvbCBwb2ludHMgYWxvbmcgZWFjaCBsaW5lIHNlZ21lbnQuXG4gIHZhciBsMXggPSAoMSAtIGFscGhhKSAqIHAxLnggKyBhbHBoYSAqIHAwLngsXG4gICAgICBsMXkgPSAoMSAtIGFscGhhKSAqIHAxLnkgKyBhbHBoYSAqIHAwLnksXG4gICAgICByMXggPSAoMSAtIGFscGhhKSAqIHAxLnggKyBhbHBoYSAqIHAyLngsXG4gICAgICByMXkgPSAoMSAtIGFscGhhKSAqIHAxLnkgKyBhbHBoYSAqIHAyLnk7XG5cbiAgLy8gU3RlcCAyOiBzaGlmdCB0aGUgcG9pbnRzIHVwIHNvIHRoYXQgcDEgaXMgb24gdGhlIGwx4oCTcjEgbGluZS5cbiAgaWYgKGwxeCAhPSByMXgpIHtcbiAgICAvLyBUaGlzIGNhbiBiZSBkZXJpdmVkIHcvIHNvbWUgYmFzaWMgYWxnZWJyYS5cbiAgICB2YXIgZGVsdGFZID0gcDEueSAtIHIxeSAtIChwMS54IC0gcjF4KSAqIChsMXkgLSByMXkpIC8gKGwxeCAtIHIxeCk7XG4gICAgbDF5ICs9IGRlbHRhWTtcbiAgICByMXkgKz0gZGVsdGFZO1xuICB9XG5cbiAgLy8gU3RlcCAzOiBjb3JyZWN0IHRvIGF2b2lkIGZhbHNlIGV4dHJlbWEuXG4gIGlmICghYWxsb3dGYWxzZUV4dHJlbWEpIHtcbiAgICBpZiAobDF5ID4gcDAueSAmJiBsMXkgPiBwMS55KSB7XG4gICAgICBsMXkgPSBNYXRoLm1heChwMC55LCBwMS55KTtcbiAgICAgIHIxeSA9IDIgKiBwMS55IC0gbDF5O1xuICAgIH0gZWxzZSBpZiAobDF5IDwgcDAueSAmJiBsMXkgPCBwMS55KSB7XG4gICAgICBsMXkgPSBNYXRoLm1pbihwMC55LCBwMS55KTtcbiAgICAgIHIxeSA9IDIgKiBwMS55IC0gbDF5O1xuICAgIH1cblxuICAgIGlmIChyMXkgPiBwMS55ICYmIHIxeSA+IHAyLnkpIHtcbiAgICAgIHIxeSA9IE1hdGgubWF4KHAxLnksIHAyLnkpO1xuICAgICAgbDF5ID0gMiAqIHAxLnkgLSByMXk7XG4gICAgfSBlbHNlIGlmIChyMXkgPCBwMS55ICYmIHIxeSA8IHAyLnkpIHtcbiAgICAgIHIxeSA9IE1hdGgubWluKHAxLnksIHAyLnkpO1xuICAgICAgbDF5ID0gMiAqIHAxLnkgLSByMXk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFtsMXgsIGwxeSwgcjF4LCByMXldO1xufVxuXG4vLyBpLmUuIGlzIG5vbmUgb2YgKG51bGwsIHVuZGVmaW5lZCwgTmFOKVxuZnVuY3Rpb24gaXNPSyh4KSB7XG4gIHJldHVybiAhIXggJiYgIWlzTmFOKHgpO1xufTtcblxuLy8gQSBwbG90dGVyIHdoaWNoIHVzZXMgc3BsaW5lcyB0byBjcmVhdGUgYSBzbW9vdGggY3VydmUuXG4vLyBTZWUgdGVzdHMvcGxvdHRlcnMuaHRtbCBmb3IgYSBkZW1vLlxuLy8gQ2FuIGJlIGNvbnRyb2xsZWQgdmlhIHNtb290aFBsb3R0ZXIuc21vb3RoaW5nXG5mdW5jdGlvbiBzbW9vdGhQbG90dGVyKGUpIHtcbiAgdmFyIGN0eCA9IGUuZHJhd2luZ0NvbnRleHQsXG4gICAgICBwb2ludHMgPSBlLnBvaW50cztcblxuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5tb3ZlVG8ocG9pbnRzWzBdLmNhbnZhc3gsIHBvaW50c1swXS5jYW52YXN5KTtcblxuICAvLyByaWdodCBjb250cm9sIHBvaW50IGZvciBwcmV2aW91cyBwb2ludFxuICB2YXIgbGFzdFJpZ2h0WCA9IHBvaW50c1swXS5jYW52YXN4LCBsYXN0UmlnaHRZID0gcG9pbnRzWzBdLmNhbnZhc3k7XG5cbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcDAgPSBwb2ludHNbaSAtIDFdLFxuICAgICAgICBwMSA9IHBvaW50c1tpXSxcbiAgICAgICAgcDIgPSBwb2ludHNbaSArIDFdO1xuICAgIHAwID0gcDAgJiYgaXNPSyhwMC5jYW52YXN5KSA/IHAwIDogbnVsbDtcbiAgICBwMSA9IHAxICYmIGlzT0socDEuY2FudmFzeSkgPyBwMSA6IG51bGw7XG4gICAgcDIgPSBwMiAmJiBpc09LKHAyLmNhbnZhc3kpID8gcDIgOiBudWxsO1xuICAgIGlmIChwMCAmJiBwMSkge1xuICAgICAgdmFyIGNvbnRyb2xzID0gZ2V0Q29udHJvbFBvaW50cyh7eDogcDAuY2FudmFzeCwgeTogcDAuY2FudmFzeX0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt4OiBwMS5jYW52YXN4LCB5OiBwMS5jYW52YXN5fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcDIgJiYge3g6IHAyLmNhbnZhc3gsIHk6IHAyLmNhbnZhc3l9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbW9vdGhQbG90dGVyLnNtb290aGluZyk7XG4gICAgICAvLyBVbmNvbW1lbnQgdG8gc2hvdyB0aGUgY29udHJvbCBwb2ludHM6XG4gICAgICAvLyBjdHgubGluZVRvKGxhc3RSaWdodFgsIGxhc3RSaWdodFkpO1xuICAgICAgLy8gY3R4LmxpbmVUbyhjb250cm9sc1swXSwgY29udHJvbHNbMV0pO1xuICAgICAgLy8gY3R4LmxpbmVUbyhwMS5jYW52YXN4LCBwMS5jYW52YXN5KTtcbiAgICAgIGxhc3RSaWdodFggPSAobGFzdFJpZ2h0WCAhPT0gbnVsbCkgPyBsYXN0UmlnaHRYIDogcDAuY2FudmFzeDtcbiAgICAgIGxhc3RSaWdodFkgPSAobGFzdFJpZ2h0WSAhPT0gbnVsbCkgPyBsYXN0UmlnaHRZIDogcDAuY2FudmFzeTtcbiAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGxhc3RSaWdodFgsIGxhc3RSaWdodFksXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sc1swXSwgY29udHJvbHNbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwMS5jYW52YXN4LCBwMS5jYW52YXN5KTtcbiAgICAgIGxhc3RSaWdodFggPSBjb250cm9sc1syXTtcbiAgICAgIGxhc3RSaWdodFkgPSBjb250cm9sc1szXTtcbiAgICB9IGVsc2UgaWYgKHAxKSB7XG4gICAgICAvLyBXZSdyZSBzdGFydGluZyBhZ2FpbiBhZnRlciBhIG1pc3NpbmcgcG9pbnQuXG4gICAgICBjdHgubW92ZVRvKHAxLmNhbnZhc3gsIHAxLmNhbnZhc3kpO1xuICAgICAgbGFzdFJpZ2h0WCA9IHAxLmNhbnZhc3g7XG4gICAgICBsYXN0UmlnaHRZID0gcDEuY2FudmFzeTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdFJpZ2h0WCA9IGxhc3RSaWdodFkgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zdHJva2UoKTtcbn1cbnNtb290aFBsb3R0ZXIuc21vb3RoaW5nID0gMS8zO1xuc21vb3RoUGxvdHRlci5fZ2V0Q29udHJvbFBvaW50cyA9IGdldENvbnRyb2xQb2ludHM7ICAvLyBmb3IgdGVzdGluZ1xuXG4vLyBvbGRlciB2ZXJzaW9ucyBleHBvcnRlZCBhIGdsb2JhbC5cbi8vIFRoaXMgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmUuXG4vLyBUaGUgcHJlZmVycmVkIHdheSB0byBhY2Nlc3Mgc21vb3RoUGxvdHRlciBpcyB2aWEgRHlncmFwaC5zbW9vdGhQbG90dGVyLlxud2luZG93LnNtb290aFBsb3R0ZXIgPSBzbW9vdGhQbG90dGVyO1xuRHlncmFwaC5zbW9vdGhQbG90dGVyID0gc21vb3RoUGxvdHRlcjtcblxuLyogY2xvc3VyZSBhbmQgbG9hZGVyIHdyYXBwZXIgKi9cbkR5Z3JhcGguX3JlcXVpcmVkKCdkeWdyYXBocy9zcmMvZXh0cmFzL3Ntb290aC1wbG90dGVyLmpzJywgLyogZXhwb3J0cyAqLyB7fSk7XG59KSgpO1xuIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDLFNBQVNBLDZCQUE2QixHQUFHO0VBQzFDLFlBQVk7O0VBQ1osSUFBSUMsT0FBTztFQUNYLElBQUlDLE1BQU0sQ0FBQ0QsT0FBTyxFQUFFO0lBQ2xCQSxPQUFPLEdBQUdDLE1BQU0sQ0FBQ0QsT0FBTztFQUMxQixDQUFDLE1BQU0sSUFBSSxPQUFPRSxNQUFPLEtBQUssV0FBVyxFQUFFO0lBQ3pDRixPQUFPLEdBQUdHLE9BQU8sQ0FBQyxZQUFZLENBQUM7SUFDL0IsSUFBSSxPQUFPSCxPQUFPLENBQUNJLElBQUssS0FBSyxXQUFXLElBQUksT0FBT0osT0FBTyxXQUFTLEtBQUssV0FBVyxFQUNqRkEsT0FBTyxHQUFHQSxPQUFPLFdBQVE7RUFDN0I7RUFDQTs7RUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0EsU0FBU0ssZ0JBQWdCLENBQUNDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLFNBQVMsRUFBRUMscUJBQXFC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